Encapsulation:

  Why_To_Learn:
    - Bundles data and behavior together
    - Protects object integrity
    - Improves maintainability
    - Reduces coupling
    - Makes domain-driven design possible
    - Core building block of enterprise systems

  Clear_Definition:
    Meaning: "Wrapping data (variables) and methods (behavior) into a single unit (class)"
    Simple_Definition: "Object controls its own data"
    Important: "Encapsulation = Data Hiding + Controlled Access"

  Core_Concept:

    Without_Encapsulation:
      Problem_Code: |
        class Order {
            public double price;
        }
      Problem:
        - Anyone can modify price
        - No validation
        - Business rules broken

    With_Encapsulation:
      Proper_Code: |
        class Order {

            private double price;

            public void setPrice(double price) {
                if(price > 0) {
                    this.price = price;
                }
            }

            public double getPrice() {
                return price;
            }
        }
      Benefit:
        - Data protected
        - Validation enforced
        - Object controls its state

  Real_Life_Example:

    ATM_Machine:
      User_Can:
        - Withdraw money
        - Check balance
      User_Cannot:
        - Directly access cash vault
        - Modify internal ledger
      Concept: "Internal state hidden, operations controlled"

  Memory_Level_Process:

    Step_1_Class_Loading:
      - Class metadata stored in Method Area
      - Fields + methods stored
      - Access modifiers recorded

    Step_2_Object_Creation:
      Code: "Order order = new Order();"
      Heap:
        Object_Type: Order
        Fields:
          price: 0.0

    Step_3_State_Modification:
      Code: "order.setPrice(1000);"
      Stack:
        - Method call frame created
      Heap:
        - price updated after validation

    Protection_Mechanism:
      - Direct access blocked by compiler
      - Only public methods allowed
      - JVM enforces access flags

  Encapsulation_vs_Data_Hiding:

    Data_Hiding:
      - Focuses on restricting access
      - Uses private keyword

    Encapsulation:
      - Combines data + behavior
      - Provides controlled operations
      - Higher-level concept

  Spring_Boot_Usage:

    Entity_Example:
      Code: |
        @Entity
        public class User {

            private String username;
            private String password;

            public String getUsername() {
                return username;
            }

            public void setUsername(String username) {
                this.username = username;
            }

            public void setPassword(String password) {
                // hashing logic before saving
                this.password = password;
            }
        }

      Explanation:
        - Password not directly exposed
        - Logic (hashing) inside setter
        - Business rule encapsulated

    Service_Layer_Encapsulation:
      Code: |
        @Service
        public class OrderService {

            public void placeOrder(Order order) {
                validate(order);
                save(order);
                sendNotification(order);
            }

            private void validate(Order order) {}
            private void save(Order order) {}
            private void sendNotification(Order order) {}
        }

      Concept:
        - Internal steps hidden
        - Controller calls only placeOrder()
        - Business workflow encapsulated

  System_Level_Benefits:
    Object_Integrity: true
    Maintainability: high
    Testability: high
    Security: improved
    Bug_Risk: reduced

  Deep_Engineering_Insight:
    - Encapsulation enables domain modeling
    - Makes microservices stable
    - Prevents unintended side effects
    - Core principle of clean architecture

  One_Line_Summary:
    "Encapsulation binds data and behavior into a single controlled unit to protect object integrity and enforce business rules."
